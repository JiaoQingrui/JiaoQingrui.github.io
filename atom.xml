<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JBlog</title>
  
  <subtitle>jioaer Blog</subtitle>
  <link href="https://jiaoqingrui.github.io/atom.xml" rel="self"/>
  
  <link href="https://jiaoqingrui.github.io/"/>
  <updated>2021-05-01T11:35:14.265Z</updated>
  <id>https://jiaoqingrui.github.io/</id>
  
  <author>
    <name>Qingrui Jiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP三次握手和四次挥手</title>
    <link href="https://jiaoqingrui.github.io/2021/05/01/CW-tcp3/4/"/>
    <id>https://jiaoqingrui.github.io/2021/05/01/CW-tcp3/4/</id>
    <published>2021-05-01T11:35:29.184Z</published>
    <updated>2021-05-01T11:35:14.265Z</updated>
    
    <content type="html"><![CDATA[<hr><p>   <img src="TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.assets/2TFnEtL1SBqgpdf.png" alt="clipboard.png"></p><p><strong>第一次握手：</strong>客户端发送请求报文段，将SYN位置置1，Sequence Number为x，然后客户机进入SYN_SEND状态，等待服务器确认</p><p><strong>第二次握手：</strong>服务器收到SYN报文段，确认 SYN报文段，设置ACK为x+1，同时将SYN位置1，SYN序列号是Y，将ACK和SYN组合成一个报文，发送给客户端，服务器进入SYN_RECV状态</p><p><strong>第三次握手：</strong>客户端收到SYN_ACK报文段，然后将ACK序号置为y+1，向服务器发送ACK报文段，报文段发送完毕之后，客户端和服务器都进入ESTABLISHED状态，完成三次握手建立连接</p><p><strong>第一次挥手：</strong>客户端发送FIN，序列号a，客户端 进入FIN_WAIT_1状态</p><p><strong>第二次挥手：</strong>服务器收到FIN，发送一个ACK，序列号a+1，进入CLOSE_WAIT状态</p><p><strong>第三次挥手：</strong>服务器发送一个FIN，序列号为，用于关闭服务器到客户端的连接，服务器进入LAST_ACK状态</p><p><strong>第四次握手：</strong>客户端收到FIN，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器，确认序列号为b+1，服务器进入CLOSED状态</p><p>补充：</p><p><strong>【问题1】</strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</p><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p><strong>【问题2】</strong>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><p><strong>【问题3】</strong>为什么不能用两次握手进行连接？</p><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p><p>​    现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><p><strong>【问题4】</strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p><strong>【问题5】</strong>分析三次握手的丢包情况</p><p>第一个包，即A发给B的SYN中途被丢，没有到达B</p><p>A会周期性超时重传，直到收到B的确认</p><p>第二个包，即B发给A的SYN +ACK中途被丢，没有到达A</p><p>B会周期性超时重传，直到收到A的确认</p><p>第三个包，即A发给B的ACK中途被丢，没有到达B</p><p>A发完ACK，单方面认为TCP为Established状态，而B显然认为TCP为Active状态:</p><p>a.假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为Established状态，双向可以发包。</p><p>b.假定此时A有数据发送，B收到A的Data + ACK，自然会切换为established状态，并接受A的Data。</p><p>c.假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。</p><p><strong>【问题6】</strong>TCP为什么是可靠连接 </p><ol><li>通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。</li><li>TCP 报文头里面的序号能使 TCP 的数据按序到达</li><li>报文头里面的确认序号能保证不丢包，累计确认及超时重传机制</li><li>TCP 拥有流量控制及拥塞控制的机制</li></ol><p>TCP 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的</p><p>拥塞控制时通过拥塞窗口来解决的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;   &lt;img src=&quot;TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.assets/2TFnEtL1SBqgpdf.png&quot; alt=&quot;c</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://jiaoqingrui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP和UDP的区别</title>
    <link href="https://jiaoqingrui.github.io/2021/05/01/CW-TCP/UDP/"/>
    <id>https://jiaoqingrui.github.io/2021/05/01/CW-TCP/UDP/</id>
    <published>2021-05-01T11:31:18.997Z</published>
    <updated>2021-05-01T11:31:05.560Z</updated>
    
    <content type="html"><![CDATA[<hr><p>TCP(传输控制协议)和UPD(用户数据报协议)是OSI参考模型中传输层的协议，TCP提供可靠的通信传输，而UDP则常被用于广播和细节控制交给应用的通信传输。</p><p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为，即使出现丢包，UDP也不负责重发，包乱序到达也没有纠错功能。</p><p>TCP提供了数据传输时的各种控制功能，可以进行丢包重发，还可以对乱序到达的包进行顺序控制，TCP是有连接的协议，只有在通信另一端确认建立连接之后才会传输数据，可以控制了流量浪费。</p><p>两者的区别大致如下 ：</p><ol><li>TCP面向连接，UDP面向非连接，即UDP发送数据之前不需要建立连接</li><li>TCP提供可靠地数据传输服务，数据无差错，不丢失，不重复，但UDP尽最大力交付，并不提供可靠交付</li><li>TCP面向字节流，UDP面向报文</li><li>TCP连接是点到点的，UDP支持一对一，一对多，多对多的交互通信</li><li>TCP收不开销20字节，UDP首部开销8字节</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP是不可靠信道</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;TCP(传输控制协议)和UPD(用户数据报协议)是OSI参考模型中传输层的协议，TCP提供可靠的通信传输，而UDP则常被用于广播和细节控制交给应用的通信传输。&lt;/p&gt;
&lt;p&gt;UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://jiaoqingrui.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Class文件结构</title>
    <link href="https://jiaoqingrui.github.io/2021/05/01/JVM-class/"/>
    <id>https://jiaoqingrui.github.io/2021/05/01/JVM-class/</id>
    <published>2021-05-01T11:16:47.516Z</published>
    <updated>2021-05-01T11:26:29.860Z</updated>
    
    <content type="html"><![CDATA[<p>Class文件主要包括：</p><ul><li><p><strong>魔数</strong></p></li><li><ul><li>cafe babe：识别class文件</li></ul></li><li><p><strong>Class文件版本</strong></p></li><li><ul><li>M.m，主版本号.副版本号    </li></ul></li><li><p><strong>常量池</strong></p></li><li><ul><li>常量池计数器：索引是 count-1, 从1开始数，0表示不引用任何一个常量池中的项目</li><li>常量池表：包括字面量和符号引用两部分</li></ul></li></ul><p>通过一个对照表才能查到每一部分是表示的什么</p><ul><li><ul><li><ul><li><p>字面量</p></li><li><ul><li>文本字符串</li><li>声明为final的常量值</li></ul></li><li><p>符号引用</p></li><li><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li></ul></li></ul></li><li><p><strong>访问标志</strong></p></li><li><p><strong>类索引、父类索引、接口索引集合</strong></p></li><li><p><strong>字段表集合</strong></p></li><li><ul><li>字段计数器</li><li>字段表（名字、类型、值、属性表等）</li></ul></li><li><p><strong>方法表集合</strong></p></li><li><ul><li>方法计数器</li><li>方法表（访问标志、方法名索引、描述符索引、属性计数器、属性集合）</li></ul></li><li><p><strong>属性表集合</strong></p></li></ul><p>class文件只有两种数据类型：无符号数 和 表</p><p>为什么要有常量池表：因为class文件无法直接被执行，需要加载才能被执行，在加载之前并不知道内存地址是什么，所以需要先保存在符号引用，加载之后通过动态链接再确定相应的地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Class文件主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;魔数&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;cafe babe：识别class文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Class文件版本&lt;/st</summary>
      
    
    
    
    <category term="JVM" scheme="https://jiaoqingrui.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://jiaoqingrui.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>双亲委派机制</title>
    <link href="https://jiaoqingrui.github.io/2021/05/01/JVM-parent/"/>
    <id>https://jiaoqingrui.github.io/2021/05/01/JVM-parent/</id>
    <published>2021-05-01T11:07:55.677Z</published>
    <updated>2021-05-01T11:07:49.884Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>jdk1.2开始：Java虚拟机对class文件采用按需加载的方式，只有在使用该类的时候才会将它的Class文件加载到内存中生成Class文件，并且在加载Class的时候使用双亲委派机制，即请求交由父类处理，它是一种任务委派模式。</p></blockquote><p><strong>工作原理：</strong></p><ol><li><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行;</p></li><li><p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归,请求最终将到达顶层的启动类加载器;</p></li><li><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p></li></ol><p><strong>优势：</strong></p><ol><li><p>避免类的重复加载，确保一个类是全局唯一的</p></li><li><p>保护程序安全，防止核心API被随意篡改</p></li></ol><p>比如自定义类定义在了Lang包下面 ，就会报错</p><p><strong>代码层面：</strong></p><ol><li><p>先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p></li><li><p>判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。</p></li><li><p>反之，如果当前加载器的父类加载器为空，则调用findBootstrapClass0rNull(name)接口，让引导类加载器进行加载。</p></li><li><p>如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.classLoader接口的defineClass系列的native接口加载目标Java类。</p></li></ol><p>双亲委派的模型就隐藏在这第2和第3步中。</p><p><strong>三次破坏行为：</strong></p><ol><li><p>JDK1.2之前不支持</p></li><li><p>线程上下文类加载器（反向委托）</p></li><li><p>用户对程序的动态性追求，如代码热替换，模块热部署</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;jdk1.2开始：Java虚拟机对class文件采用按需加载的方式，只有在使用该类的时候才会将它的Class文件加载到内存中生成Class文件，并且在加载Class的时候使用双亲委派机制，即请求交由父类处理，它是一种任务委派模式。&lt;/p&gt;</summary>
      
    
    
    
    <category term="JVM" scheme="https://jiaoqingrui.github.io/categories/JVM/"/>
    
    
    <category term="JVM" scheme="https://jiaoqingrui.github.io/tags/JVM/"/>
    
    <category term="Java" scheme="https://jiaoqingrui.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://jiaoqingrui.github.io/2021/05/01/undefined/"/>
    <id>https://jiaoqingrui.github.io/2021/05/01/undefined/</id>
    <published>2021-05-01T10:06:16.076Z</published>
    <updated>2021-05-01T10:06:16.076Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
