<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JiaoerBlog</title>
  
  <subtitle>jioaer Blog</subtitle>
  <link href="http://www.jiaoer.site/atom.xml" rel="self"/>
  
  <link href="http://www.jiaoer.site/"/>
  <updated>2021-05-02T07:50:17.019Z</updated>
  <id>http://www.jiaoer.site/</id>
  
  <author>
    <name>Qingrui Jiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>十种排序算法Java实现</title>
    <link href="http://www.jiaoer.site/2021/05/02/%E5%8D%81%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Java%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.jiaoer.site/2021/05/02/%E5%8D%81%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Java%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-05-02T07:52:01.350Z</published>
    <updated>2021-05-02T07:50:17.019Z</updated>
    
    <content type="html"><![CDATA[<hr><p>参考了排序算法的动图根据自己的理解写得排序算法，只是想实现基本的功能，没有仔细考虑如何优化代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSortAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] sortedNums = nums.clone();</span><br><span class="line">        Arrays.sort(sortedNums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] bubbleSortRes = bubbleSort(nums.clone());</span><br><span class="line">        <span class="keyword">int</span>[] selectionSortRes = selectionSort(nums.clone());</span><br><span class="line">        <span class="keyword">int</span>[] insertionSortRes = insertionSort(nums.clone());</span><br><span class="line">        <span class="keyword">int</span>[] shellSortRes = shellSort(nums.clone());</span><br><span class="line">        <span class="keyword">int</span>[] mergeSortRes = mergeSort(nums.clone());</span><br><span class="line">        <span class="keyword">int</span>[] quickSortRes = quickSort(nums.clone(), <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] heapSortRes = heapSort(nums.clone());</span><br><span class="line">        <span class="keyword">int</span>[] countingSortRes = countingSort(nums.clone());</span><br><span class="line">        <span class="keyword">int</span>[] bucketSortRes = bucketSort(nums.clone());</span><br><span class="line">        <span class="keyword">int</span>[] radixSortRes = radixSort(nums.clone());</span><br><span class="line">        System.out.println(<span class="string">&quot;冒泡：&quot;</span> + Arrays.toString(bubbleSortRes) + <span class="string">&quot;  &quot;</span> + Arrays.equals(sortedNums, bubbleSortRes));</span><br><span class="line">        System.out.println(<span class="string">&quot;选择：&quot;</span> + Arrays.toString(selectionSortRes) + <span class="string">&quot;  &quot;</span> + Arrays.equals(sortedNums, selectionSortRes));</span><br><span class="line">        System.out.println(<span class="string">&quot;插入：&quot;</span> + Arrays.toString(insertionSortRes) + <span class="string">&quot;  &quot;</span> + Arrays.equals(sortedNums, insertionSortRes));</span><br><span class="line">        System.out.println(<span class="string">&quot;希尔：&quot;</span> + Arrays.toString(shellSortRes) + <span class="string">&quot;  &quot;</span> + Arrays.equals(sortedNums, shellSortRes));</span><br><span class="line">        System.out.println(<span class="string">&quot;归并：&quot;</span> + Arrays.toString(mergeSortRes) + <span class="string">&quot;  &quot;</span> + Arrays.equals(sortedNums, mergeSortRes));</span><br><span class="line">        System.out.println(<span class="string">&quot;快速：&quot;</span> + Arrays.toString(quickSortRes) + <span class="string">&quot;  &quot;</span> + Arrays.equals(sortedNums, quickSortRes));</span><br><span class="line">        System.out.println(<span class="string">&quot;堆排：&quot;</span> + Arrays.toString(heapSortRes) + <span class="string">&quot;  &quot;</span> + Arrays.equals(sortedNums, heapSortRes));</span><br><span class="line">        System.out.println(<span class="string">&quot;计数：&quot;</span> + Arrays.toString(countingSortRes) + <span class="string">&quot;  &quot;</span> + Arrays.equals(sortedNums, countingSortRes));</span><br><span class="line">        System.out.println(<span class="string">&quot;桶排：&quot;</span> + Arrays.toString(bucketSortRes) + <span class="string">&quot;  &quot;</span> + Arrays.equals(sortedNums, bucketSortRes));</span><br><span class="line">        System.out.println(<span class="string">&quot;基数：&quot;</span> + Arrays.toString(radixSortRes) + <span class="string">&quot;  &quot;</span> + Arrays.equals(sortedNums, radixSortRes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.冒泡排序 O(n^2)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.选择排序 O(n^2)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[minIndex] &gt; nums[j])&#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[minIndex];</span><br><span class="line">            nums[minIndex] = nums[i];</span><br><span class="line">            nums[i] =temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.插入排序 O(n^2)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertionSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> currIndex = i;</span><br><span class="line">            <span class="keyword">int</span> insertNum = nums[currIndex];</span><br><span class="line">            <span class="keyword">while</span> (currIndex &gt; <span class="number">0</span> &amp;&amp; insertNum &lt; nums[currIndex - <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[currIndex] = nums[currIndex - <span class="number">1</span>];</span><br><span class="line">                currIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[currIndex] = insertNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.希尔排序 O(n^1.3)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = len/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap = gap/<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> insertNum = nums[i];</span><br><span class="line">                <span class="keyword">int</span> currIndex = i;</span><br><span class="line">                <span class="keyword">while</span> (currIndex - gap &gt;= <span class="number">0</span> &amp;&amp; nums[currIndex - gap] &gt; insertNum) &#123;</span><br><span class="line">                    nums[currIndex] = nums[currIndex - gap];</span><br><span class="line">                    currIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[currIndex] = insertNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.归并排序 O(nlog_2_n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> mid = nums.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] left = Arrays.copyOfRange(nums, <span class="number">0</span>, mid);</span><br><span class="line">        <span class="keyword">int</span>[] right = Arrays.copyOfRange(nums, mid, nums.length);</span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入的left 和 right 数组是已经排好序的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; index &lt; result.length; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= left.length) &#123;</span><br><span class="line">                result[index] = right[j++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= right.length) &#123;</span><br><span class="line">                result[index] = left[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left[i] &lt; right[j]) &#123;</span><br><span class="line">                result[index] = left[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[index] = right[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.快速排序 O(nlog_2_n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">1</span> || start &lt; <span class="number">0</span> || end &gt; nums.length || start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> standardIndex = partition(nums, start, end);</span><br><span class="line">        quickSort(nums, start, standardIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, standardIndex + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> standardNum = nums[left];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt; standardNum) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right &amp;&amp; nums[left] &lt; standardNum) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = standardNum;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.堆排序 O(nlog_2_n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        buildMaxHeap(nums);</span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">            len--;</span><br><span class="line">            adjustHeap(nums, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(nums, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = i;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; len &amp;&amp; nums[left] &gt; nums[maxIndex]) maxIndex = left;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; len &amp;&amp; nums[right] &gt; nums[maxIndex]) maxIndex = right;</span><br><span class="line">        <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">            swap(nums, maxIndex, i);</span><br><span class="line">            adjustHeap(nums, maxIndex, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.计数排序 O(n+k)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countingSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>], max = min;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">            min = Math.min(min, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            counts[num-min]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> countIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(counts[countIndex] == <span class="number">0</span>) &#123;</span><br><span class="line">                countIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = countIndex + min;</span><br><span class="line">            counts[countIndex]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9.桶排序 O(n+k)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>], max = min;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">            min = Math.min(min, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> bucketCapacity = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> bucketNum = (max - min) / bucketCapacity + <span class="number">1</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            buckets.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            buckets.get((num - min) / bucketCapacity ).add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">            Collections.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (Integer integer : bucket) &#123;</span><br><span class="line">                nums[index++] = integer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10.基数排序 O(n+k)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLength = (max + <span class="string">&quot;&quot;</span>).length();<span class="comment">//计算位数</span></span><br><span class="line">        List&lt;Queue&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buckets.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">int</span> remain = (num / n) % <span class="number">10</span>;</span><br><span class="line">                buckets.get(remain).offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Queue&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!bucket.isEmpty()) &#123;</span><br><span class="line">                    nums[index++] = bucket.poll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;参考了排序算法的动图根据自己的理解写得排序算法，只是想实现基本的功能，没有仔细考虑如何优化代码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="数据机构与算法" scheme="http://www.jiaoer.site/categories/%E6%95%B0%E6%8D%AE%E6%9C%BA%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="java" scheme="http://www.jiaoer.site/tags/java/"/>
    
    <category term="排序算法" scheme="http://www.jiaoer.site/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB启动速度慢的解决办法</title>
    <link href="http://www.jiaoer.site/2021/05/02/MATLAB%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://www.jiaoer.site/2021/05/02/MATLAB%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</id>
    <published>2021-05-02T07:48:07.489Z</published>
    <updated>2021-05-02T07:47:44.083Z</updated>
    
    <content type="html"><![CDATA[<hr><p>MATLAB R2019b 用软件激活之后，每次打开都需要7分钟左右时间，但是在开启的过程中360显示内存占用并没有明显的变化，因此推测不是电脑性能不够，虽然实验室电脑已经很老了。<br>在网上寻找诸多方法后发现有一条方法可以完美解决启动慢的问题</p><p>我的系统是Windows10，MATLAB安装在  <code>D：\MatlabR2019b</code></p><p><strong>解决方案</strong></p><ol><li>如果MATLAB没有创建快捷方式，在安装目录  <code>D：\MatlabR2019b\bin</code>目录下把<code>matlab.exe</code>发送到桌面快捷方式</li><li>在桌面右键<code>matlab.exe</code>，在      <strong>快捷方式</strong>   —    <strong>目标</strong> 下设置写入如下语句<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;D:\MatlabR2019b\bin\matlab.exe&quot;</span> -c <span class="string">&quot;D:\MatlabR2019b\license_standalone.lic&quot;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>以上，第一个引号内是MATLAB安装路径</li><li>第二个引号是注册时用到的.lic文件的绝对路径，我是放在了MATLAB安装的根目录下，当然也可以放在别的地方<br>只需要添加这一条就可以实现，亲测有效，不需要一直直直直等待了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;MATLAB R2019b 用软件激活之后，每次打开都需要7分钟左右时间，但是在开启的过程中360显示内存占用并没有明显的变化，因此推测不是电脑性能不够，虽然实验室电脑已经很老了。&lt;br&gt;在网上寻找诸多方法后发现有一条方法可以完美解决启动慢的问题&lt;/p&gt;
&lt;p&gt;我</summary>
      
    
    
    
    <category term="软件问题" scheme="http://www.jiaoer.site/categories/%E8%BD%AF%E4%BB%B6%E9%97%AE%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP三次握手和四次挥手</title>
    <link href="http://www.jiaoer.site/2021/05/01/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://www.jiaoer.site/2021/05/01/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2021-05-01T11:35:29.184Z</published>
    <updated>2021-05-01T11:48:37.157Z</updated>
    
    <content type="html"><![CDATA[<hr><p><img src="https://i.loli.net/2021/05/01/2TFnEtL1SBqgpdf.png" alt="clipboard.png"></p><p><strong>第一次握手：</strong>客户端发送请求报文段，将SYN位置置1，Sequence Number为x，然后客户机进入SYN_SEND状态，等待服务器确认</p><p><strong>第二次握手：</strong>服务器收到SYN报文段，确认 SYN报文段，设置ACK为x+1，同时将SYN位置1，SYN序列号是Y，将ACK和SYN组合成一个报文，发送给客户端，服务器进入SYN_RECV状态</p><p><strong>第三次握手：</strong>客户端收到SYN_ACK报文段，然后将ACK序号置为y+1，向服务器发送ACK报文段，报文段发送完毕之后，客户端和服务器都进入ESTABLISHED状态，完成三次握手建立连接</p><p><strong>第一次挥手：</strong>客户端发送FIN，序列号a，客户端 进入FIN_WAIT_1状态</p><p><strong>第二次挥手：</strong>服务器收到FIN，发送一个ACK，序列号a+1，进入CLOSE_WAIT状态</p><p><strong>第三次挥手：</strong>服务器发送一个FIN，序列号为，用于关闭服务器到客户端的连接，服务器进入LAST_ACK状态</p><p><strong>第四次握手：</strong>客户端收到FIN，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器，确认序列号为b+1，服务器进入CLOSED状态</p><p>补充：</p><p><strong>【问题1】</strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</p><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p><strong>【问题2】</strong>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><p><strong>【问题3】</strong>为什么不能用两次握手进行连接？</p><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p><p>​    现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><p><strong>【问题4】</strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p><strong>【问题5】</strong>分析三次握手的丢包情况</p><p>第一个包，即A发给B的SYN中途被丢，没有到达B</p><p>A会周期性超时重传，直到收到B的确认</p><p>第二个包，即B发给A的SYN +ACK中途被丢，没有到达A</p><p>B会周期性超时重传，直到收到A的确认</p><p>第三个包，即A发给B的ACK中途被丢，没有到达B</p><p>A发完ACK，单方面认为TCP为Established状态，而B显然认为TCP为Active状态:</p><p>a.假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为Established状态，双向可以发包。</p><p>b.假定此时A有数据发送，B收到A的Data + ACK，自然会切换为established状态，并接受A的Data。</p><p>c.假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。</p><p><strong>【问题6】</strong>TCP为什么是可靠连接 </p><ol><li>通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。</li><li>TCP 报文头里面的序号能使 TCP 的数据按序到达</li><li>报文头里面的确认序号能保证不丢包，累计确认及超时重传机制</li><li>TCP 拥有流量控制及拥塞控制的机制</li></ol><p>TCP 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的</p><p>拥塞控制时通过拥塞窗口来解决的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/01/2TFnEtL1SBqgpdf.png&quot; alt=&quot;clipboard.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一次握手：&lt;/strong&gt;客户端发送请求报文段，将SYN位置置1，</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://www.jiaoer.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP和UDP的区别</title>
    <link href="http://www.jiaoer.site/2021/05/01/TCP%E5%92%8CUPD%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.jiaoer.site/2021/05/01/TCP%E5%92%8CUPD%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-05-01T11:31:18.997Z</published>
    <updated>2021-05-01T11:31:05.560Z</updated>
    
    <content type="html"><![CDATA[<hr><p>TCP(传输控制协议)和UPD(用户数据报协议)是OSI参考模型中传输层的协议，TCP提供可靠的通信传输，而UDP则常被用于广播和细节控制交给应用的通信传输。</p><p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为，即使出现丢包，UDP也不负责重发，包乱序到达也没有纠错功能。</p><p>TCP提供了数据传输时的各种控制功能，可以进行丢包重发，还可以对乱序到达的包进行顺序控制，TCP是有连接的协议，只有在通信另一端确认建立连接之后才会传输数据，可以控制了流量浪费。</p><p>两者的区别大致如下 ：</p><ol><li>TCP面向连接，UDP面向非连接，即UDP发送数据之前不需要建立连接</li><li>TCP提供可靠地数据传输服务，数据无差错，不丢失，不重复，但UDP尽最大力交付，并不提供可靠交付</li><li>TCP面向字节流，UDP面向报文</li><li>TCP连接是点到点的，UDP支持一对一，一对多，多对多的交互通信</li><li>TCP收不开销20字节，UDP首部开销8字节</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP是不可靠信道</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;TCP(传输控制协议)和UPD(用户数据报协议)是OSI参考模型中传输层的协议，TCP提供可靠的通信传输，而UDP则常被用于广播和细节控制交给应用的通信传输。&lt;/p&gt;
&lt;p&gt;UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://www.jiaoer.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Class文件结构</title>
    <link href="http://www.jiaoer.site/2021/05/01/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://www.jiaoer.site/2021/05/01/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2021-05-01T11:16:47.516Z</published>
    <updated>2021-05-01T11:26:29.860Z</updated>
    
    <content type="html"><![CDATA[<p>Class文件主要包括：</p><ul><li><p><strong>魔数</strong></p></li><li><ul><li>cafe babe：识别class文件</li></ul></li><li><p><strong>Class文件版本</strong></p></li><li><ul><li>M.m，主版本号.副版本号    </li></ul></li><li><p><strong>常量池</strong></p></li><li><ul><li>常量池计数器：索引是 count-1, 从1开始数，0表示不引用任何一个常量池中的项目</li><li>常量池表：包括字面量和符号引用两部分</li></ul></li></ul><p>通过一个对照表才能查到每一部分是表示的什么</p><ul><li><ul><li><ul><li><p>字面量</p></li><li><ul><li>文本字符串</li><li>声明为final的常量值</li></ul></li><li><p>符号引用</p></li><li><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li></ul></li></ul></li><li><p><strong>访问标志</strong></p></li><li><p><strong>类索引、父类索引、接口索引集合</strong></p></li><li><p><strong>字段表集合</strong></p></li><li><ul><li>字段计数器</li><li>字段表（名字、类型、值、属性表等）</li></ul></li><li><p><strong>方法表集合</strong></p></li><li><ul><li>方法计数器</li><li>方法表（访问标志、方法名索引、描述符索引、属性计数器、属性集合）</li></ul></li><li><p><strong>属性表集合</strong></p></li></ul><p>class文件只有两种数据类型：无符号数 和 表</p><p>为什么要有常量池表：因为class文件无法直接被执行，需要加载才能被执行，在加载之前并不知道内存地址是什么，所以需要先保存在符号引用，加载之后通过动态链接再确定相应的地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Class文件主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;魔数&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;cafe babe：识别class文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Class文件版本&lt;/st</summary>
      
    
    
    
    <category term="JVM" scheme="http://www.jiaoer.site/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://www.jiaoer.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>双亲委派机制</title>
    <link href="http://www.jiaoer.site/2021/05/01/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.jiaoer.site/2021/05/01/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</id>
    <published>2021-05-01T11:07:55.677Z</published>
    <updated>2021-05-01T11:07:49.884Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>jdk1.2开始：Java虚拟机对class文件采用按需加载的方式，只有在使用该类的时候才会将它的Class文件加载到内存中生成Class文件，并且在加载Class的时候使用双亲委派机制，即请求交由父类处理，它是一种任务委派模式。</p></blockquote><p><strong>工作原理：</strong></p><ol><li><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行;</p></li><li><p>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归,请求最终将到达顶层的启动类加载器;</p></li><li><p>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p></li></ol><p><strong>优势：</strong></p><ol><li><p>避免类的重复加载，确保一个类是全局唯一的</p></li><li><p>保护程序安全，防止核心API被随意篡改</p></li></ol><p>比如自定义类定义在了Lang包下面 ，就会报错</p><p><strong>代码层面：</strong></p><ol><li><p>先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p></li><li><p>判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。</p></li><li><p>反之，如果当前加载器的父类加载器为空，则调用findBootstrapClass0rNull(name)接口，让引导类加载器进行加载。</p></li><li><p>如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.classLoader接口的defineClass系列的native接口加载目标Java类。</p></li></ol><p>双亲委派的模型就隐藏在这第2和第3步中。</p><p><strong>三次破坏行为：</strong></p><ol><li><p>JDK1.2之前不支持</p></li><li><p>线程上下文类加载器（反向委托）</p></li><li><p>用户对程序的动态性追求，如代码热替换，模块热部署</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;jdk1.2开始：Java虚拟机对class文件采用按需加载的方式，只有在使用该类的时候才会将它的Class文件加载到内存中生成Class文件，并且在加载Class的时候使用双亲委派机制，即请求交由父类处理，它是一种任务委派模式。&lt;/p&gt;</summary>
      
    
    
    
    <category term="JVM" scheme="http://www.jiaoer.site/categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://www.jiaoer.site/tags/JVM/"/>
    
    <category term="Java" scheme="http://www.jiaoer.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.jiaoer.site/2021/05/01/hello-world/"/>
    <id>http://www.jiaoer.site/2021/05/01/hello-world/</id>
    <published>2021-05-01T10:06:16.076Z</published>
    <updated>2021-05-01T10:06:16.076Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
