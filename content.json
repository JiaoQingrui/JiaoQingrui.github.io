{"meta":{"title":"JBlog","subtitle":"jioaer Blog","description":"","author":"Qingrui Jiao","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-05-01T10:09:21.420Z","updated":"2021-05-01T10:09:21.420Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"书单","date":"2021-05-01T10:09:21.422Z","updated":"2021-05-01T10:09:21.422Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-05-01T10:09:21.422Z","updated":"2021-05-01T10:09:21.422Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-05-01T10:09:21.421Z","updated":"2021-05-01T10:09:21.421Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2021-05-01T10:09:21.423Z","updated":"2021-05-01T10:09:21.423Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-05-01T10:09:21.423Z","updated":"2021-05-01T10:09:21.423Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-05-01T10:09:21.424Z","updated":"2021-05-01T10:09:21.424Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"双亲委派机制","slug":"双亲委派机制","date":"2021-05-01T11:07:55.677Z","updated":"2021-05-01T11:07:49.884Z","comments":true,"path":"2021/05/01/JVM-parent/","link":"","permalink":"http://example.com/2021/05/01/JVM-parent/","excerpt":"","text":"jdk1.2开始：Java虚拟机对class文件采用按需加载的方式，只有在使用该类的时候才会将它的Class文件加载到内存中生成Class文件，并且在加载Class的时候使用双亲委派机制，即请求交由父类处理，它是一种任务委派模式。 工作原理： 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行; 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归,请求最终将到达顶层的启动类加载器; 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 优势： 避免类的重复加载，确保一个类是全局唯一的 保护程序安全，防止核心API被随意篡改 比如自定义类定义在了Lang包下面 ，就会报错 代码层面： 先在当前加载器的缓存中查找有无目标类，如果有，直接返回。 判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。 反之，如果当前加载器的父类加载器为空，则调用findBootstrapClass0rNull(name)接口，让引导类加载器进行加载。 如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.classLoader接口的defineClass系列的native接口加载目标Java类。 双亲委派的模型就隐藏在这第2和第3步中。 三次破坏行为： JDK1.2之前不支持 线程上下文类加载器（反向委托） 用户对程序的动态性追求，如代码热替换，模块热部署","categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-05-01T10:06:16.076Z","updated":"2021-05-01T10:06:16.076Z","comments":true,"path":"2021/05/01/undefined/","link":"","permalink":"http://example.com/2021/05/01/undefined/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://example.com/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}