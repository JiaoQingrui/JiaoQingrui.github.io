{"meta":{"title":"JiaoerBlog","subtitle":"jioaer Blog","description":"","author":"Qingrui Jiao","url":"http://www.jiaoer.site","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-06-07T11:40:35.538Z","updated":"2021-05-01T10:09:21.420Z","comments":false,"path":"/404.html","permalink":"http://www.jiaoer.site/404.html","excerpt":"","text":""},{"title":"书单","date":"2021-06-07T11:40:35.539Z","updated":"2021-05-01T10:09:21.422Z","comments":false,"path":"books/index.html","permalink":"http://www.jiaoer.site/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-06-07T11:40:35.540Z","updated":"2021-05-01T10:09:21.422Z","comments":false,"path":"categories/index.html","permalink":"http://www.jiaoer.site/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-06-07T11:40:35.539Z","updated":"2021-05-01T10:09:21.421Z","comments":false,"path":"about/index.html","permalink":"http://www.jiaoer.site/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2021-06-07T11:40:35.541Z","updated":"2021-05-01T10:09:21.423Z","comments":false,"path":"repository/index.html","permalink":"http://www.jiaoer.site/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-06-07T11:40:35.541Z","updated":"2021-05-01T10:09:21.423Z","comments":true,"path":"links/index.html","permalink":"http://www.jiaoer.site/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-06-07T11:40:35.542Z","updated":"2021-05-01T10:09:21.424Z","comments":false,"path":"tags/index.html","permalink":"http://www.jiaoer.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"十种排序算法Java实现","slug":"十种排序算法Java实现","date":"2021-05-02T07:52:01.350Z","updated":"2021-05-02T07:50:17.019Z","comments":true,"path":"2021/05/02/alg-sort/","link":"","permalink":"http://www.jiaoer.site/2021/05/02/alg-sort/","excerpt":"","text":"参考了排序算法的动图根据自己的理解写得排序算法，只是想实现基本的功能，没有仔细考虑如何优化代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257import java.util.*;public class TestSortAlgorithm &#123; public static void main(String[] args) &#123; int[] nums = &#123;3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48&#125;; int[] sortedNums = nums.clone(); Arrays.sort(sortedNums); int[] bubbleSortRes = bubbleSort(nums.clone()); int[] selectionSortRes = selectionSort(nums.clone()); int[] insertionSortRes = insertionSort(nums.clone()); int[] shellSortRes = shellSort(nums.clone()); int[] mergeSortRes = mergeSort(nums.clone()); int[] quickSortRes = quickSort(nums.clone(), 0, nums.length-1); int[] heapSortRes = heapSort(nums.clone()); int[] countingSortRes = countingSort(nums.clone()); int[] bucketSortRes = bucketSort(nums.clone()); int[] radixSortRes = radixSort(nums.clone()); System.out.println(&quot;冒泡：&quot; + Arrays.toString(bubbleSortRes) + &quot; &quot; + Arrays.equals(sortedNums, bubbleSortRes)); System.out.println(&quot;选择：&quot; + Arrays.toString(selectionSortRes) + &quot; &quot; + Arrays.equals(sortedNums, selectionSortRes)); System.out.println(&quot;插入：&quot; + Arrays.toString(insertionSortRes) + &quot; &quot; + Arrays.equals(sortedNums, insertionSortRes)); System.out.println(&quot;希尔：&quot; + Arrays.toString(shellSortRes) + &quot; &quot; + Arrays.equals(sortedNums, shellSortRes)); System.out.println(&quot;归并：&quot; + Arrays.toString(mergeSortRes) + &quot; &quot; + Arrays.equals(sortedNums, mergeSortRes)); System.out.println(&quot;快速：&quot; + Arrays.toString(quickSortRes) + &quot; &quot; + Arrays.equals(sortedNums, quickSortRes)); System.out.println(&quot;堆排：&quot; + Arrays.toString(heapSortRes) + &quot; &quot; + Arrays.equals(sortedNums, heapSortRes)); System.out.println(&quot;计数：&quot; + Arrays.toString(countingSortRes) + &quot; &quot; + Arrays.equals(sortedNums, countingSortRes)); System.out.println(&quot;桶排：&quot; + Arrays.toString(bucketSortRes) + &quot; &quot; + Arrays.equals(sortedNums, bucketSortRes)); System.out.println(&quot;基数：&quot; + Arrays.toString(radixSortRes) + &quot; &quot; + Arrays.equals(sortedNums, radixSortRes)); &#125; // 1.冒泡排序 O(n^2) public static int[] bubbleSort(int[] nums)&#123; int len = nums.length; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; if(nums[i] &gt; nums[j])&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; &#125; &#125; return nums; &#125; // 2.选择排序 O(n^2) public static int[] selectionSort(int[] nums)&#123; int len = nums.length; for (int i = 0; i &lt; len - 1; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt;len; j++) &#123; if(nums[minIndex] &gt; nums[j])&#123; minIndex = j; &#125; &#125; int temp = nums[minIndex]; nums[minIndex] = nums[i]; nums[i] =temp; &#125; return nums; &#125; // 3.插入排序 O(n^2) public static int[] insertionSort(int[] nums)&#123; int len = nums.length; for (int i = 1; i &lt; len; i++) &#123; int currIndex = i; int insertNum = nums[currIndex]; while (currIndex &gt; 0 &amp;&amp; insertNum &lt; nums[currIndex - 1]) &#123; nums[currIndex] = nums[currIndex - 1]; currIndex--; &#125; nums[currIndex] = insertNum; &#125; return nums; &#125; // 4.希尔排序 O(n^1.3) public static int[] shellSort(int[] nums)&#123; int len = nums.length; for (int gap = len/2; gap &gt; 0; gap = gap/2) &#123; for (int i = gap; i &lt; len; i++) &#123; int insertNum = nums[i]; int currIndex = i; while (currIndex - gap &gt;= 0 &amp;&amp; nums[currIndex - gap] &gt; insertNum) &#123; nums[currIndex] = nums[currIndex - gap]; currIndex -= gap; &#125; nums[currIndex] = insertNum; &#125; &#125; return nums; &#125; // 5.归并排序 O(nlog_2_n) public static int[] mergeSort(int[] nums)&#123; if (nums.length &lt; 2) return nums; int mid = nums.length / 2; int[] left = Arrays.copyOfRange(nums, 0, mid); int[] right = Arrays.copyOfRange(nums, mid, nums.length); return merge(mergeSort(left), mergeSort(right)); &#125; //输入的left 和 right 数组是已经排好序的数组 private static int[] merge(int[] left, int[] right) &#123; int[] result = new int[left.length + right.length]; for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) &#123; if (i &gt;= left.length) &#123; result[index] = right[j++]; &#125; else if (j &gt;= right.length) &#123; result[index] = left[i++]; &#125; else if (left[i] &lt; right[j]) &#123; result[index] = left[i++]; &#125; else &#123; result[index] = right[j++]; &#125; &#125; return result; &#125; // 6.快速排序 O(nlog_2_n) public static int[] quickSort(int[] nums, int start, int end)&#123; if (nums.length &lt; 1 || start &lt; 0 || end &gt; nums.length || start &gt; end) return null; int standardIndex = partition(nums, start, end); quickSort(nums, start, standardIndex - 1); quickSort(nums, standardIndex + 1, end); return nums; &#125; private static int partition(int[] nums, int left, int right) &#123; int standardNum = nums[left]; while(left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[right] &gt; standardNum) &#123; right--; &#125; nums[left] = nums[right]; if (left &lt; right &amp;&amp; nums[left] &lt; standardNum) &#123; left++; &#125; nums[right] = nums[left]; &#125; nums[left] = standardNum; return left; &#125; // 7.堆排序 O(nlog_2_n) public static int[] heapSort(int[] nums)&#123; int len = nums.length; if (len &lt; 1) return nums; buildMaxHeap(nums); while (len &gt; 0) &#123; swap(nums, 0, len - 1); len--; adjustHeap(nums, 0, len); &#125; return nums; &#125; private static void swap(int[] nums, int a, int b) &#123; int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; &#125; private static void buildMaxHeap(int[] nums) &#123; int len = nums.length; for (int i = len / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(nums, i, len); &#125; &#125; private static void adjustHeap(int[] nums, int i, int len) &#123; int left = 2 * i + 1; int right = 2 * i + 2; int maxIndex = i; if (left &lt; len &amp;&amp; nums[left] &gt; nums[maxIndex]) maxIndex = left; if (right &lt; len &amp;&amp; nums[right] &gt; nums[maxIndex]) maxIndex = right; if (maxIndex != i) &#123; swap(nums, maxIndex, i); adjustHeap(nums, maxIndex, len); &#125; &#125; // 8.计数排序 O(n+k) public static int[] countingSort(int[] nums)&#123; int min = nums[0], max = min; for (int num : nums) &#123; max = Math.max(max, num); min = Math.min(min, num); &#125; int[] counts = new int[max - min + 1]; for (int num : nums) &#123; counts[num-min]++; &#125; int countIndex = 0; for (int i = 0; i &lt; nums.length; i++) &#123; while(counts[countIndex] == 0) &#123; countIndex++; &#125; nums[i] = countIndex + min; counts[countIndex]--; &#125; return nums; &#125; // 9.桶排序 O(n+k) public static int[] bucketSort(int[] nums)&#123; int min = nums[0], max = min; for (int num : nums) &#123; max = Math.max(max, num); min = Math.min(min, num); &#125; int bucketCapacity = 10; int bucketNum = (max - min) / bucketCapacity + 1; List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;(bucketNum); for (int i = 0; i &lt; bucketNum; i++) &#123; buckets.add(new ArrayList&lt;&gt;()); &#125; for (int num : nums) &#123; buckets.get((num - min) / bucketCapacity ).add(num); &#125; int index = 0; for (List&lt;Integer&gt; bucket : buckets) &#123; Collections.sort(bucket); for (Integer integer : bucket) &#123; nums[index++] = integer; &#125; &#125; return nums; &#125; // 10.基数排序 O(n+k) public static int[] radixSort(int[] nums)&#123; int max = nums[0]; for (int num : nums) &#123; max = Math.max(max, num); &#125; int maxLength = (max + &quot;&quot;).length();//计算位数 List&lt;Queue&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;(10); for (int i = 0; i &lt; 10; i++) &#123; buckets.add(new LinkedList&lt;&gt;()); &#125; for (int i = 0, n = 1; i &lt; maxLength; i++, n *= 10) &#123; for (int num : nums) &#123; int remain = (num / n) % 10; buckets.get(remain).offer(num); &#125; int index = 0; for (Queue&lt;Integer&gt; bucket : buckets) &#123; while (!bucket.isEmpty()) &#123; nums[index++] = bucket.poll(); &#125; &#125; &#125; return nums; &#125;&#125;","categories":[{"name":"数据机构与算法","slug":"数据机构与算法","permalink":"http://www.jiaoer.site/categories/%E6%95%B0%E6%8D%AE%E6%9C%BA%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.jiaoer.site/tags/java/"},{"name":"排序算法","slug":"排序算法","permalink":"http://www.jiaoer.site/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"MATLAB启动速度慢的解决办法","slug":"MATLAB启动速度慢的解决办法","date":"2021-05-02T07:48:07.489Z","updated":"2021-05-02T07:47:44.083Z","comments":true,"path":"2021/05/02/other-matlab/","link":"","permalink":"http://www.jiaoer.site/2021/05/02/other-matlab/","excerpt":"","text":"MATLAB R2019b 用软件激活之后，每次打开都需要7分钟左右时间，但是在开启的过程中360显示内存占用并没有明显的变化，因此推测不是电脑性能不够，虽然实验室电脑已经很老了。在网上寻找诸多方法后发现有一条方法可以完美解决启动慢的问题 我的系统是Windows10，MATLAB安装在 D：\\MatlabR2019b 解决方案 如果MATLAB没有创建快捷方式，在安装目录 D：\\MatlabR2019b\\bin目录下把matlab.exe发送到桌面快捷方式 在桌面右键matlab.exe，在 快捷方式 — 目标 下设置写入如下语句1&quot;D:\\MatlabR2019b\\bin\\matlab.exe&quot; -c &quot;D:\\MatlabR2019b\\license_standalone.lic&quot; 以上，第一个引号内是MATLAB安装路径 第二个引号是注册时用到的.lic文件的绝对路径，我是放在了MATLAB安装的根目录下，当然也可以放在别的地方只需要添加这一条就可以实现，亲测有效，不需要一直直直直等待了","categories":[{"name":"软件问题","slug":"软件问题","permalink":"http://www.jiaoer.site/categories/%E8%BD%AF%E4%BB%B6%E9%97%AE%E9%A2%98/"}],"tags":[]},{"title":"TCP三次握手和四次挥手","slug":"TCP三次握手和四次挥手","date":"2021-05-01T11:35:29.184Z","updated":"2021-05-01T11:48:37.157Z","comments":true,"path":"2021/05/01/CW-tcp3/4/","link":"","permalink":"http://www.jiaoer.site/2021/05/01/CW-tcp3/4/","excerpt":"","text":"第一次握手：客户端发送请求报文段，将SYN位置置1，Sequence Number为x，然后客户机进入SYN_SEND状态，等待服务器确认 第二次握手：服务器收到SYN报文段，确认 SYN报文段，设置ACK为x+1，同时将SYN位置1，SYN序列号是Y，将ACK和SYN组合成一个报文，发送给客户端，服务器进入SYN_RECV状态 第三次握手：客户端收到SYN_ACK报文段，然后将ACK序号置为y+1，向服务器发送ACK报文段，报文段发送完毕之后，客户端和服务器都进入ESTABLISHED状态，完成三次握手建立连接 第一次挥手：客户端发送FIN，序列号a，客户端 进入FIN_WAIT_1状态 第二次挥手：服务器收到FIN，发送一个ACK，序列号a+1，进入CLOSE_WAIT状态 第三次挥手：服务器发送一个FIN，序列号为，用于关闭服务器到客户端的连接，服务器进入LAST_ACK状态 第四次握手：客户端收到FIN，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器，确认序列号为b+1，服务器进入CLOSED状态 补充： 【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？ 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假想网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 【问题3】为什么不能用两次握手进行连接？ 答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 ​ 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 【问题5】分析三次握手的丢包情况 第一个包，即A发给B的SYN中途被丢，没有到达B A会周期性超时重传，直到收到B的确认 第二个包，即B发给A的SYN +ACK中途被丢，没有到达A B会周期性超时重传，直到收到A的确认 第三个包，即A发给B的ACK中途被丢，没有到达B A发完ACK，单方面认为TCP为Established状态，而B显然认为TCP为Active状态: a.假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为Established状态，双向可以发包。 b.假定此时A有数据发送，B收到A的Data + ACK，自然会切换为established状态，并接受A的Data。 c.假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。 【问题6】TCP为什么是可靠连接 通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。 TCP 报文头里面的序号能使 TCP 的数据按序到达 报文头里面的确认序号能保证不丢包，累计确认及超时重传机制 TCP 拥有流量控制及拥塞控制的机制 TCP 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的 拥塞控制时通过拥塞窗口来解决的","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.jiaoer.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"TCP和UDP的区别","slug":"TCP和UPD的区别","date":"2021-05-01T11:31:18.997Z","updated":"2021-05-01T11:31:05.560Z","comments":true,"path":"2021/05/01/CW-TCP/UDP/","link":"","permalink":"http://www.jiaoer.site/2021/05/01/CW-TCP/UDP/","excerpt":"","text":"TCP(传输控制协议)和UPD(用户数据报协议)是OSI参考模型中传输层的协议，TCP提供可靠的通信传输，而UDP则常被用于广播和细节控制交给应用的通信传输。 UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为，即使出现丢包，UDP也不负责重发，包乱序到达也没有纠错功能。 TCP提供了数据传输时的各种控制功能，可以进行丢包重发，还可以对乱序到达的包进行顺序控制，TCP是有连接的协议，只有在通信另一端确认建立连接之后才会传输数据，可以控制了流量浪费。 两者的区别大致如下 ： TCP面向连接，UDP面向非连接，即UDP发送数据之前不需要建立连接 TCP提供可靠地数据传输服务，数据无差错，不丢失，不重复，但UDP尽最大力交付，并不提供可靠交付 TCP面向字节流，UDP面向报文 TCP连接是点到点的，UDP支持一对一，一对多，多对多的交互通信 TCP收不开销20字节，UDP首部开销8字节 TCP的逻辑通信信道是全双工的可靠信道，UDP是不可靠信道","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.jiaoer.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"Class文件结构","slug":"Class文件结构","date":"2021-05-01T11:16:47.516Z","updated":"2021-05-01T11:26:29.860Z","comments":true,"path":"2021/05/01/JVM-class/","link":"","permalink":"http://www.jiaoer.site/2021/05/01/JVM-class/","excerpt":"","text":"Class文件主要包括： 魔数 cafe babe：识别class文件 Class文件版本 M.m，主版本号.副版本号 常量池 常量池计数器：索引是 count-1, 从1开始数，0表示不引用任何一个常量池中的项目 常量池表：包括字面量和符号引用两部分 通过一个对照表才能查到每一部分是表示的什么 字面量 文本字符串 声明为final的常量值 符号引用 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 访问标志 类索引、父类索引、接口索引集合 字段表集合 字段计数器 字段表（名字、类型、值、属性表等） 方法表集合 方法计数器 方法表（访问标志、方法名索引、描述符索引、属性计数器、属性集合） 属性表集合 class文件只有两种数据类型：无符号数 和 表 为什么要有常量池表：因为class文件无法直接被执行，需要加载才能被执行，在加载之前并不知道内存地址是什么，所以需要先保存在符号引用，加载之后通过动态链接再确定相应的地址","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.jiaoer.site/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.jiaoer.site/tags/JVM/"}]},{"title":"双亲委派机制","slug":"双亲委派机制","date":"2021-05-01T11:07:55.677Z","updated":"2021-05-01T11:07:49.884Z","comments":true,"path":"2021/05/01/JVM-parent/","link":"","permalink":"http://www.jiaoer.site/2021/05/01/JVM-parent/","excerpt":"","text":"jdk1.2开始：Java虚拟机对class文件采用按需加载的方式，只有在使用该类的时候才会将它的Class文件加载到内存中生成Class文件，并且在加载Class的时候使用双亲委派机制，即请求交由父类处理，它是一种任务委派模式。 工作原理： 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行; 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归,请求最终将到达顶层的启动类加载器; 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 优势： 避免类的重复加载，确保一个类是全局唯一的 保护程序安全，防止核心API被随意篡改 比如自定义类定义在了Lang包下面 ，就会报错 代码层面： 先在当前加载器的缓存中查找有无目标类，如果有，直接返回。 判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。 反之，如果当前加载器的父类加载器为空，则调用findBootstrapClass0rNull(name)接口，让引导类加载器进行加载。 如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.classLoader接口的defineClass系列的native接口加载目标Java类。 双亲委派的模型就隐藏在这第2和第3步中。 三次破坏行为： JDK1.2之前不支持 线程上下文类加载器（反向委托） 用户对程序的动态性追求，如代码热替换，模块热部署","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.jiaoer.site/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.jiaoer.site/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://www.jiaoer.site/tags/Java/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-05-01T10:06:16.076Z","updated":"2021-05-01T10:06:16.076Z","comments":true,"path":"2021/05/01/undefined/","link":"","permalink":"http://www.jiaoer.site/2021/05/01/undefined/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"数据机构与算法","slug":"数据机构与算法","permalink":"http://www.jiaoer.site/categories/%E6%95%B0%E6%8D%AE%E6%9C%BA%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"软件问题","slug":"软件问题","permalink":"http://www.jiaoer.site/categories/%E8%BD%AF%E4%BB%B6%E9%97%AE%E9%A2%98/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.jiaoer.site/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"JVM","slug":"JVM","permalink":"http://www.jiaoer.site/categories/JVM/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.jiaoer.site/tags/java/"},{"name":"排序算法","slug":"排序算法","permalink":"http://www.jiaoer.site/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"JVM","slug":"JVM","permalink":"http://www.jiaoer.site/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"http://www.jiaoer.site/tags/Java/"}]}